#!/usr/bin/env python
# coding: utf-8
# 
# TST-Online command line identifiers quality checker. based on a well-known gold standard recommended in
# a book and also adopted by some software engineering literature initiatives towards improving the iden-
# tifiers quality. Also, it is based on a previously developed tool: qcheck.
#
# Marcos Nascimento, 2018-2019

import os
import sys
import json
import codecs
import glob
import argparse
import qchecklib
import tstlib
import os.path

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

import bin
from bin import iqchecklib
from fileinput import filename
from argparse import RawTextHelpFormatter

# Feedback Messages
NOREFERENCE = "There are no words or reference terms."
#NOREFERENCE = "Não há palavras ou termos de referência."
NOTSUITABLENAME = "does not appear to be a suitable name. You should use words from the programming assignment description."
#NOTSUITABLENAME = "não parece ser um nome adequado. Use palavras da descrição da atividade."
NOWARNINGS = "No warnings. Congratulations!"
#NOWARNINGS = "Nenhuma advertência. Parabéns!"

# Output Settings
COLNUMBERWIDTH = 5
COLTEXTWIDTH = 25
IQCHECKFILE = "iqcheck.json"
TSTFILE = ".tst/tst.json"
TSTDIR = os.path.expanduser("~/.tst/")
TSTCONFIG = os.path.expanduser(TSTDIR + "config.json")

LBLUE = '\033[1;34m'
LGREEN = '\033[1;32m'
LCYAN = '\033[1;36m'
RESET = '\033[0m'
BOLD = '\033[1m'

def quality_report( raw_report ):
    report = {}
    if not raw_report:
        report["message"] = NOREFERENCE

    #Iqcheck
    if raw_report.get("iqcheck"):
        report["iqcheck"] = raw_report.get("iqcheck")
    
    return report

def get_problem_vocabulary(): 
    iqcheckjson = read_iqcheckjson(exit=True)
    if iqcheckjson.get("problem_vocabulary"):
        return iqcheckjson.get("problem_vocabulary")
    else:
        return {}

def get_reference_identifiers(): 
    iqcheckjson = read_iqcheckjson(exit=True)
    if iqcheckjson.get("reference_identifiers"):
        return iqcheckjson.get("reference_identifiers")
    else:
        return {}

def get_report(filename):
    results = {
        "iqcheck": iqchecklib.ichecking(get_problem_vocabulary(), filename)
    }
    return results

def get_rawmetrics(filename):
    results = {
        "iqcheck": iqchecklib.get_studentidentifiers(filename)
    }  
    return results

def get_username():
    configjson = read_tstconfig(exit=True)
    if configjson.get("user"):
        return configjson.get("user")
    else:
        return ''

def get_activityid():
    tstjson = read_tstjson(exit=True)
    if tstjson.get("iid"):
        return tstjson.get("iid")
    else:
        return '0'
    
def get_logdata(filenames, output):
    content = { "filename": filenames }
    content["iid"] = get_activityid()
    content["user"] = get_username()
    content["identifiers"] = iqchecklib.get_studentidentifiers(filenames) 
    content["positives"] = iqchecklib.get_positives(get_problem_vocabulary(), filenames)
    content["negatives"] = iqchecklib.get_negatives(get_problem_vocabulary(), filenames)
    content["iqcheckscore"] = iqchecklib.icheckscore(get_problem_vocabulary(), filenames)
    return content
    
def pack_logfeedback(results):
    identifier = 0
    identifiers_feedback = ["iqcheck"]
    for feedback, message in results.items():
        if len(message) > 1:
            if feedback in identifiers_feedback:
                identifier += 1    
    report = { "identifierwarning": identifier, "feedback": results }
    return report

def pack_markdownfeedback(filename, results):
    identifierline = "### Identifiers\n"
    #identifierline = "### Identificadores\n"
    
    identifierwarnings = 0
    
    if not results:
        return ""
    
    #Iqcheck
    if results.get("iqcheck") and len(results.get("iqcheck")) >= 1:
        for i in range(0, len(results.get("iqcheck"))):
            identifierline += '- {}*{}*{} {}\n'.format(BOLD,
                                                       results.get("iqcheck")[i],
                                                       RESET,
                                                       NOTSUITABLENAME) 
            identifierwarnings += 1
    
    if identifierwarnings:
        header = LBLUE + "# %s\n\n" % filename
        report = LCYAN + "**%d Warning(s)** \n\n" % (identifierwarnings) + RESET
        #report = LCYAN + "**%d Advertência(s)** \n\n" % (identifierwarnings) + RESET
        messages = identifierline if identifierwarnings else ""

        text = header + report + messages[:-1]
    else:
        text = LCYAN + "** %s **" % NOWARNINGS + RESET
    
    return text

def pack_readablemetrics(results):
    line = ""
    if not results:
        return line

    #Iqcheckscore
    if results.get("iqcheckscore") is not None:
        line += '{0:>{width}.{precision}f}'.format(results.get("iqcheckscore"), \
                                                   width = COLNUMBERWIDTH + 3, precision = 2)
    return line

def pack_results(results):    
    return tstlib.data2json(results)

def write_results(tag, results, IQCHECKFILE):
    iqcheckjson = read_iqcheckjson(exit=True)
    
    if tag == "problem_vocabulary":
        if not get_problem_vocabulary():
            iqcheckjson[tag] = results
            with codecs.open(IQCHECKFILE, mode='w', encoding='utf-8') as fp:
                json.dump(iqcheckjson, fp, indent = 2, separators=(',', ': '), ensure_ascii=False)

        else:
            with codecs.open(IQCHECKFILE, mode='r', encoding='utf-8') as jf:
                data = json.load(jf)
            data[tag] = results
            with codecs.open(IQCHECKFILE, mode='w', encoding='utf-8') as fp:
                json.dump(data, fp, indent = 2, separators=(',', ': '), ensure_ascii=False)
    else:
        if not get_reference_identifiers():
            iqcheckjson[tag] = results
            with codecs.open(IQCHECKFILE, mode='w', encoding='utf-8') as fp:
                json.dump(iqcheckjson, fp, indent = 2, separators=(',', ': '), ensure_ascii=False)

        else:
            with codecs.open(IQCHECKFILE, mode='r', encoding='utf-8') as jf:
                data = json.load(jf)
            data[tag] = results
            with codecs.open(IQCHECKFILE, mode='w', encoding='utf-8') as fp:
                json.dump(data, fp, indent = 2, separators=(',', ': '), ensure_ascii=False)
    
def read_tstconfig(exit=False, quit_on_fail=False):
    #Code borrowed from tstlib.py (c) 2011-2014 Dalton Serey, UFCG
    if not os.path.exists(TSTCONFIG):
        if quit_on_fail:
            msg = "iqcheck: config.json file not found"
            print msg
            #sys.exit(1)
        return {}
    try:
        with codecs.open(TSTCONFIG, mode='r', encoding='utf-8') as f:
            configjson = json.loads(tstlib.to_unicode(f.read()))
    except ValueError:
        msg = "iqcheck: %s is corrupted" % TSTCONFIG
        if exit_on_fail:
            print msg
            #sys.exit()
        raise CorruptedFile(msg)
        
    return configjson

def read_tstjson(exit=False, quit_on_fail=False):
    #Code borrowed from tstlib.py (c) 2011-2014 Dalton Serey, UFCG
    if not os.path.exists(TSTFILE):
        if quit_on_fail:
            msg = "iqcheck: tst.json file not found"
            print msg
            #sys.exit(1)
        return {}
    try:
        with codecs.open(TSTFILE, mode='r', encoding='utf-8') as f:
            tstjson = json.loads(tstlib.to_unicode(f.read()))
        f.close()

    except ValueError:
        msg = "iqcheck: %s is corrupted" % TSTFILE
        if exit or quit_on_fail:
            print msg
            #sys.exit(1)
        raise CorruptedConfigFile(msg)
    
    return tstjson

def read_iqcheckjson(exit=False, quit_on_fail=False):
	#Code borrowed from tstlib.py (c) 2011-2014 Dalton Serey, UFCG  
    if not os.path.exists(IQCHECKFILE):
        if quit_on_fail:
            msg = "iqcheck: file not found"
            print msg
            sys.exit(1)
        return {}
    try:
        with codecs.open(IQCHECKFILE, mode='r', encoding='utf-8') as f:
            iqcheckjson = json.loads(tstlib.to_unicode(f.read()))
        f.close()

    except ValueError:
        msg = "iqcheck: %s is corrupted" % IQCHECKFILE
        if exit or quit_on_fail:
            print msg
            sys.exit(1)
        raise CorruptedConfigFile(msg)
    
    return iqcheckjson

def get_problemvocabulary(problem_file):
    return iqchecklib.generate_problemvocabulary(problem_file)

def parse_arguments():
    parser = argparse.ArgumentParser(description='Check python code identifiers quality.',
                                      formatter_class=RawTextHelpFormatter)
    parser.add_argument("-m", "--metrics",
                         nargs = 1,
                         help="get value of iqcheckscore")
    parser.add_argument("-f", "-fb", "--feedback",
                         nargs = 1,
                         help="present warning messages referring to code identifiers quality")
    parser.add_argument("-s","--set",
                         nargs = 1,
                         help="set reference vocabulary and identifiers")
    parser.add_argument("-o", "--outputformat",
                        type=str, default="human",
                        choices=["human","json"],
                        help="set output format")
    
    parser.add_argument("filename", nargs="*", default = [""])
    
    args = parser.parse_args()
    if args.metrics:
        filenames = args.metrics[0]
        function = "metrics"
    elif args.set:
        filenames = args.set[0]
        function = "set"
    elif args.feedback:
        filenames = args.feedback[0]
        function = "feedback"
    elif args.filename:
        filenames = args.filename[0]
        function = "feedback"
    
    return filenames, function, args.outputformat

def main():   
    filenames, function, outputformat = parse_arguments()
    logit = ""
    try:
        if function in ('metrics') :
            # metrics output human-readable format
            if 
            results["iqcheckscore"] = iqchecklib.icheckscore(get_problem_vocabulary(), filenames)
            report = pack_results(results) if outputformat == 'json' else pack_readablemetrics(results)
            
        elif function in ('set'): 
            # set reference solution file               
            problem_file = glob.glob('*.yaml')
            if not problem_file:
                print( "iqcheck: the problem specification description in yaml file is needed.")
                sys.exit()

            elif problem_file and not problem_file[0]:
                print( "iqcheck: the problem specification description in yaml file is needed.")
                sys.exit()

            problem_vocabulary = get_problemvocabulary(problem_file[0])
            write_results("problem_vocabulary", problem_vocabulary, IQCHECKFILE)
            results = get_rawmetrics(filenames)
            #write_results(results, IQCHECKFILE)
            write_results("reference_identifiers", results, IQCHECKFILE)

            report = IQCHECKFILE + " was created."

        elif function in ('feedback'): 
            # feedback output human-readable format
            problem_file = glob.glob('*.yaml')
            if not get_problemvocabulary(problem_file[0]):
                report = NOREFERENCE
            else:
                write_results("problem_vocabulary", get_problemvocabulary(problem_file[0]), IQCHECKFILE)
                results = quality_report(get_report(filenames))
                report = pack_results(results) if outputformat == 'json' else pack_markdownfeedback(filenames, results)
                logit = get_logdata(filenames, pack_logfeedback(results))
        
        print report
        # is log active?
        if logit:
            iqchecklib.save(logit)
            
    except IOError:
        print("Usage: tst iqcheck [options] code.py")
        sys.exit(1)
    
if __name__ == "__main__":
    
    if len(sys.argv) < 2:
        print("Usage: tst iqcheck [options] code.py")
        sys.exit()
     
    if len(sys.argv) > 1 and sys.argv[1] == '--one-line-help':
        print("check code identifiers quality")
        sys.exit()
    
    main()